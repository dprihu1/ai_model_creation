"""
text2paths.py

This module provides utilities to parse a text-based tree structure (e.g., generated by the `tree` command)
and convert it into a list of file and directory paths. It also includes functionality to create those
paths on the filesystem.

Main Features:
--------------

- Parse indented tree-like text into structured paths.
- Clean and normalize path strings by removing comments and tree formatting characters.
- Reconstruct the directory structure on disk by creating files and folders.

Example Input:
--------------

Given an input like:

    project/
    ├── src/
    │   ├── main.py
    │   └── utils.py
    └── README.md

The module will produce:

    ['project/',
     'project/src/',
     'project/src/main.py',
     'project/src/utils.py',
     'project/README.md']

Functions:
----------

- remove_comments(line): Remove inline comments from a line.
- remove_tree_symbols(line): Strip tree diagram symbols from a line.
- extract_clean_path(line): Extract the clean file or directory name from a line.
- parse_text_tree(lines): Parse a list of lines into relative paths.
- create_path(path): Create the given path on disk (file or directory).
- create_all_paths(paths): Create a list of paths on disk.

Usage Example:
--------------

    with open("tree.txt") as f:
        lines = f.readlines()

    paths = parse_text_tree(lines)
    create_all_paths(paths)

Author: You
License: MIT
"""


import os
import re

# ---------- Text Cleaning Helpers ----------

def remove_comments(line: str) -> str:
    """Remove comments from a line (anything after #)."""
    return re.sub(r'#.*', '', line).rstrip()

def remove_tree_symbols(line: str) -> str:
    """Remove tree formatting symbols from a line."""
    for symbol in ('│   ', '├── ', '└── '):
        line = line.replace(symbol, '')
    return line.strip()

def extract_clean_path(line: str) -> str:
    """Extract the last component from a line, assumed to be a path or directory/file name."""
    line = remove_comments(line)
    match = re.search(r'([^\s\\/]+/?)$', line.strip())
    return match.group(1) if match else ''

# ---------- Path Extraction ----------

def parse_text_tree(lines: list) -> list:
    """Convert a tree-structured text into a list of relative paths."""
    paths = []
    stack = []
    root = None

    for line in lines:
        clean_line = remove_comments(line)

        # Detect root
        if root is None and clean_line.strip().endswith('/'):
            root = extract_clean_path(clean_line).rstrip('/')
            stack = [root]
            paths.append(root + '/')
            continue

        if root is None:
            continue  # Skip until root is found

        # Determine depth by counting indentation patterns
        depth = clean_line.count('│   ') + clean_line.count('    ')

        name = extract_clean_path(clean_line)
        if not name:
            continue

        is_dir = name.endswith('/')
        name = name.rstrip('/') if is_dir else name

        stack = stack[:depth] + [name]
        relative_path = '/'.join(stack)
        full_path = f"{root}/{relative_path}/" if is_dir else f"{root}/{relative_path}"
        paths.append(full_path)

    return paths

# ---------- File System Utilities ----------

def create_path(path: str):
    """Create a file or directory at the given path."""
    if path.endswith('/'):
        os.makedirs(path, exist_ok=True)
    else:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        open(path, 'a').close()

# ---------- Optional Utility to Create All Paths ----------

def create_all_paths(paths: list):
    """Create a list of paths (files and directories) on disk."""
    for path in paths:
        create_path(path)
